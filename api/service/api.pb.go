// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/mesg-foundation/core/api/service/api.proto

/*
Package service is a generated protocol buffer package.

It is generated from these files:
	github.com/mesg-foundation/core/api/service/api.proto

It has these top-level messages:
	EmitEventRequest
	ListenTaskRequest
	SubmitResultRequest
	EmitEventReply
	TaskData
	SubmitResultReply
*/
package service

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Data sent while calling the `EmitEvent` API.
//
// **Example:**
// ```json
// {
//   "token": "TOKEN_FROM_ENV",
//   "eventKey": "eventX",
//   "eventData": "{\"foo\":\"hello\",\"bar\":false}"
// }
// ```
type EmitEventRequest struct {
	Token     string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
	EventKey  string `protobuf:"bytes,2,opt,name=eventKey" json:"eventKey,omitempty"`
	EventData string `protobuf:"bytes,3,opt,name=eventData" json:"eventData,omitempty"`
}

func (m *EmitEventRequest) Reset()                    { *m = EmitEventRequest{} }
func (m *EmitEventRequest) String() string            { return proto.CompactTextString(m) }
func (*EmitEventRequest) ProtoMessage()               {}
func (*EmitEventRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EmitEventRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *EmitEventRequest) GetEventKey() string {
	if m != nil {
		return m.EventKey
	}
	return ""
}

func (m *EmitEventRequest) GetEventData() string {
	if m != nil {
		return m.EventData
	}
	return ""
}

// Data sent to connect to the `ListenTask` stream API.
//
// **Example:**
// ```json
// {
//   "token": "TOKEN_FROM_ENV"
// }
// ```
type ListenTaskRequest struct {
	Token string `protobuf:"bytes,1,opt,name=token" json:"token,omitempty"`
}

func (m *ListenTaskRequest) Reset()                    { *m = ListenTaskRequest{} }
func (m *ListenTaskRequest) String() string            { return proto.CompactTextString(m) }
func (*ListenTaskRequest) ProtoMessage()               {}
func (*ListenTaskRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ListenTaskRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

// Data sent while submitting a a result for a task.
// This result can only be called once inside a request from `ListenTask` because of its dependency with the `executionID``
//
// **Example:**
// ```json
// {
//   "executionID": "xxxxxx",
//   "outputKey": "outputX",
//   "outputData": "{\"foo\":\"super result\",\"bar\":true}"
// }
// ```
type SubmitResultRequest struct {
	ExecutionID string `protobuf:"bytes,1,opt,name=executionID" json:"executionID,omitempty"`
	OutputKey   string `protobuf:"bytes,2,opt,name=outputKey" json:"outputKey,omitempty"`
	OutputData  string `protobuf:"bytes,3,opt,name=outputData" json:"outputData,omitempty"`
}

func (m *SubmitResultRequest) Reset()                    { *m = SubmitResultRequest{} }
func (m *SubmitResultRequest) String() string            { return proto.CompactTextString(m) }
func (*SubmitResultRequest) ProtoMessage()               {}
func (*SubmitResultRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SubmitResultRequest) GetExecutionID() string {
	if m != nil {
		return m.ExecutionID
	}
	return ""
}

func (m *SubmitResultRequest) GetOutputKey() string {
	if m != nil {
		return m.OutputKey
	}
	return ""
}

func (m *SubmitResultRequest) GetOutputData() string {
	if m != nil {
		return m.OutputData
	}
	return ""
}

// Response of the Core when receiving an event from the `EmitEvent` call
//
// **Example:**
// ```json
// {}
// ```
type EmitEventReply struct {
}

func (m *EmitEventReply) Reset()                    { *m = EmitEventReply{} }
func (m *EmitEventReply) String() string            { return proto.CompactTextString(m) }
func (*EmitEventReply) ProtoMessage()               {}
func (*EmitEventReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// Data sent through the stream from the `ListenTask` API
// These data can come as long as the stream stays open. They contains all necessary informations to process a task.
// The `executionID` needs to be kept and sent back with the `submitResult` API
//
// **Example:**
// ```json
// {
//   "executionID": "xxxxxx",
//   "taskKey": "taskX",
//   "inputData": "{\"inputX\":\"Hello world!\",\"inputY\":true}"
// }
// ```
type TaskData struct {
	ExecutionID string `protobuf:"bytes,1,opt,name=executionID" json:"executionID,omitempty"`
	TaskKey     string `protobuf:"bytes,2,opt,name=taskKey" json:"taskKey,omitempty"`
	InputData   string `protobuf:"bytes,3,opt,name=inputData" json:"inputData,omitempty"`
}

func (m *TaskData) Reset()                    { *m = TaskData{} }
func (m *TaskData) String() string            { return proto.CompactTextString(m) }
func (*TaskData) ProtoMessage()               {}
func (*TaskData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TaskData) GetExecutionID() string {
	if m != nil {
		return m.ExecutionID
	}
	return ""
}

func (m *TaskData) GetTaskKey() string {
	if m != nil {
		return m.TaskKey
	}
	return ""
}

func (m *TaskData) GetInputData() string {
	if m != nil {
		return m.InputData
	}
	return ""
}

// Response of the Core when receiving an result from the `SubmitResult` call
//
// **Example:**
// ```json
// {}
// ```
type SubmitResultReply struct {
}

func (m *SubmitResultReply) Reset()                    { *m = SubmitResultReply{} }
func (m *SubmitResultReply) String() string            { return proto.CompactTextString(m) }
func (*SubmitResultReply) ProtoMessage()               {}
func (*SubmitResultReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func init() {
	proto.RegisterType((*EmitEventRequest)(nil), "api.EmitEventRequest")
	proto.RegisterType((*ListenTaskRequest)(nil), "api.ListenTaskRequest")
	proto.RegisterType((*SubmitResultRequest)(nil), "api.SubmitResultRequest")
	proto.RegisterType((*EmitEventReply)(nil), "api.EmitEventReply")
	proto.RegisterType((*TaskData)(nil), "api.TaskData")
	proto.RegisterType((*SubmitResultReply)(nil), "api.SubmitResultReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Service service

type ServiceClient interface {
	// Let you to emit an event to the [Core](../guide/start-here/core.md) based on the ones defined in your [mesg.yml](../guide/service/service-file.md).
	EmitEvent(ctx context.Context, in *EmitEventRequest, opts ...grpc.CallOption) (*EmitEventReply, error)
	// Subscribe to the stream of tasks that will receive tasks from the [Core](../guide/start-here/core.md)
	ListenTask(ctx context.Context, in *ListenTaskRequest, opts ...grpc.CallOption) (Service_ListenTaskClient, error)
	// Let you submit a result from a task to the [Core](../guide/start-here/core.md). The result should be an output of the tasks
	SubmitResult(ctx context.Context, in *SubmitResultRequest, opts ...grpc.CallOption) (*SubmitResultReply, error)
}

type serviceClient struct {
	cc *grpc.ClientConn
}

func NewServiceClient(cc *grpc.ClientConn) ServiceClient {
	return &serviceClient{cc}
}

func (c *serviceClient) EmitEvent(ctx context.Context, in *EmitEventRequest, opts ...grpc.CallOption) (*EmitEventReply, error) {
	out := new(EmitEventReply)
	err := grpc.Invoke(ctx, "/api.Service/EmitEvent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceClient) ListenTask(ctx context.Context, in *ListenTaskRequest, opts ...grpc.CallOption) (Service_ListenTaskClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Service_serviceDesc.Streams[0], c.cc, "/api.Service/ListenTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &serviceListenTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Service_ListenTaskClient interface {
	Recv() (*TaskData, error)
	grpc.ClientStream
}

type serviceListenTaskClient struct {
	grpc.ClientStream
}

func (x *serviceListenTaskClient) Recv() (*TaskData, error) {
	m := new(TaskData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *serviceClient) SubmitResult(ctx context.Context, in *SubmitResultRequest, opts ...grpc.CallOption) (*SubmitResultReply, error) {
	out := new(SubmitResultReply)
	err := grpc.Invoke(ctx, "/api.Service/SubmitResult", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Service service

type ServiceServer interface {
	// Let you to emit an event to the [Core](../guide/start-here/core.md) based on the ones defined in your [mesg.yml](../guide/service/service-file.md).
	EmitEvent(context.Context, *EmitEventRequest) (*EmitEventReply, error)
	// Subscribe to the stream of tasks that will receive tasks from the [Core](../guide/start-here/core.md)
	ListenTask(*ListenTaskRequest, Service_ListenTaskServer) error
	// Let you submit a result from a task to the [Core](../guide/start-here/core.md). The result should be an output of the tasks
	SubmitResult(context.Context, *SubmitResultRequest) (*SubmitResultReply, error)
}

func RegisterServiceServer(s *grpc.Server, srv ServiceServer) {
	s.RegisterService(&_Service_serviceDesc, srv)
}

func _Service_EmitEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmitEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).EmitEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Service/EmitEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).EmitEvent(ctx, req.(*EmitEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Service_ListenTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ServiceServer).ListenTask(m, &serviceListenTaskServer{stream})
}

type Service_ListenTaskServer interface {
	Send(*TaskData) error
	grpc.ServerStream
}

type serviceListenTaskServer struct {
	grpc.ServerStream
}

func (x *serviceListenTaskServer) Send(m *TaskData) error {
	return x.ServerStream.SendMsg(m)
}

func _Service_SubmitResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SubmitResultRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceServer).SubmitResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Service/SubmitResult",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceServer).SubmitResult(ctx, req.(*SubmitResultRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Service_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Service",
	HandlerType: (*ServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EmitEvent",
			Handler:    _Service_EmitEvent_Handler,
		},
		{
			MethodName: "SubmitResult",
			Handler:    _Service_SubmitResult_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListenTask",
			Handler:       _Service_ListenTask_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "github.com/mesg-foundation/core/api/service/api.proto",
}

func init() {
	proto.RegisterFile("github.com/mesg-foundation/core/api/service/api.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 338 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0x4f, 0x4f, 0x02, 0x31,
	0x10, 0xc5, 0x59, 0x89, 0xc2, 0x8e, 0x7f, 0x02, 0x45, 0xc9, 0x66, 0x63, 0x0c, 0xe9, 0x49, 0x0f,
	0xb2, 0x46, 0x63, 0x8c, 0x57, 0x02, 0x07, 0xa3, 0x27, 0xf0, 0xe4, 0xad, 0xbb, 0x8c, 0xd8, 0xc0,
	0x6e, 0x57, 0xda, 0x12, 0xf9, 0x78, 0x7e, 0x33, 0xd3, 0xf2, 0x67, 0x0b, 0x12, 0xe3, 0xad, 0xf3,
	0x66, 0x9a, 0xf7, 0x9b, 0xbe, 0xc2, 0xfd, 0x88, 0xab, 0x0f, 0x1d, 0xb7, 0x13, 0x91, 0x46, 0x29,
	0xca, 0xd1, 0xf5, 0xbb, 0xd0, 0xd9, 0x90, 0x29, 0x2e, 0xb2, 0x28, 0x11, 0x53, 0x8c, 0x58, 0xce,
	0x23, 0x89, 0xd3, 0x19, 0x4f, 0xec, 0xb9, 0x9d, 0x4f, 0x85, 0x12, 0xa4, 0xcc, 0x72, 0x4e, 0x63,
	0xa8, 0xf5, 0x52, 0xae, 0x7a, 0x33, 0xcc, 0x54, 0x1f, 0x3f, 0x35, 0x4a, 0x45, 0x4e, 0x61, 0x5f,
	0x89, 0x31, 0x66, 0x81, 0xd7, 0xf2, 0x2e, 0xfd, 0xfe, 0xa2, 0x20, 0x21, 0x54, 0xd1, 0x4c, 0x3d,
	0xe3, 0x3c, 0xd8, 0xb3, 0x8d, 0x75, 0x4d, 0xce, 0xc1, 0xb7, 0xe7, 0x2e, 0x53, 0x2c, 0x28, 0xdb,
	0x66, 0x21, 0xd0, 0x2b, 0xa8, 0xbf, 0x70, 0xa9, 0x30, 0x7b, 0x65, 0x72, 0xfc, 0xa7, 0x09, 0xd5,
	0xd0, 0x18, 0xe8, 0x38, 0xe5, 0xaa, 0x8f, 0x52, 0x4f, 0xd6, 0x44, 0x2d, 0x38, 0xc4, 0x2f, 0x4c,
	0xb4, 0x59, 0xe9, 0xa9, 0xbb, 0xbc, 0xe2, 0x4a, 0x86, 0x40, 0x68, 0x95, 0x6b, 0x07, 0xaf, 0x10,
	0xc8, 0x05, 0xc0, 0xa2, 0x70, 0x00, 0x1d, 0x85, 0xd6, 0xe0, 0xc4, 0x79, 0x85, 0x7c, 0x32, 0xa7,
	0x43, 0xa8, 0x1a, 0x5a, 0xd3, 0xfd, 0x87, 0x7b, 0x00, 0x15, 0xc5, 0xe4, 0xb8, 0xf0, 0x5e, 0x95,
	0x86, 0x8b, 0x67, 0x9b, 0xc6, 0x85, 0x40, 0x1b, 0x50, 0xdf, 0x5c, 0x37, 0x9f, 0xcc, 0x6f, 0xbf,
	0x3d, 0xa8, 0x0c, 0x16, 0x69, 0x91, 0x47, 0xf0, 0xd7, 0x60, 0xe4, 0xac, 0x6d, 0xc2, 0xdb, 0x8e,
	0x2b, 0x6c, 0x6c, 0xcb, 0x86, 0xbf, 0x44, 0x1e, 0x00, 0x8a, 0x57, 0x27, 0x4d, 0x3b, 0xf4, 0x2b,
	0x86, 0xf0, 0xd8, 0xea, 0xab, 0x55, 0x69, 0xe9, 0xc6, 0x23, 0x1d, 0x38, 0x72, 0xa1, 0x48, 0x60,
	0x47, 0x76, 0xc4, 0x12, 0x36, 0x77, 0x74, 0xac, 0x79, 0xc7, 0x7f, 0xab, 0x2c, 0x3f, 0x5c, 0x7c,
	0x60, 0x7f, 0xdb, 0xdd, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x61, 0x7d, 0xb0, 0xc8, 0xa6, 0x02,
	0x00, 0x00,
}
